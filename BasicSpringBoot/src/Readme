Object Mapper란?
스프릴ㅇ 부트에서 제이슨으로 전달되는 데이터를 역질렬화를 통해서 DTO 형태 자바 클래스 형태로 바꿔주는 역할과 반대로 우리가 응답을 내릴때 DTO 을 내릴때 json 형태로 바꿔주는 역할을 한다.
그래서 잭슨 라이브러리라고도 하는데 (Jackson Lib) 이것외에도 다양한것이 있는데 Gson이라고 구글에서 제공해주느것도 있지만 스프링부트에서 Jackson을 토대로 역직렬화 직렬화를 한다.
JsonProperty를 사용했을때 우리가 이메일이나 이름 혹은 좀 다른 제목으로 들어오는것들을 변경해줄수 있다.
@JsonProperty("EMAIL")
private String mail;
이런식으로 되어있을때 저 변수에는 무조건 받는값을 대문쟈 EMAIL이라고 한다면 json형식에 키값이 EMAIL로 변경이 된다.

Readvalue 즉 json를 DTO 로 변경할때 setter 메소드를 참고하는데 setter 메소드가 없다면 get 메소드를 통해서도 세팅이 가능하다는 것을 우리는 알수있다.

가장 좋은 연습은 가장 기본을 사용하면서 @Data 와 기본생성자 모든 생성자를 달아주면 우리가 코딩하는데 큰 문제가 없고 기본형태를 추천한다
ㅏ간혼 가다가 좀 특이한 프로퍼티가 있다면 json 프로퍼티로 매칭을 해주면됩니다.

스프링부트를 활용하다가 뭔가 json 데이터가 잘 안만들어지거나 매칭이 잘 안될때는 방금의 동작 원리를 꼭 기억하시기 바랍니다.

--------------------------------------------------------------------------------------------------------

springboot에서 예외처리

동작 원리 -
인터넨ㅅ으로부터 리퀘스트 요청이 들어오게되면 필터를 통과하게 된다 그리고 디스패처 서블릿을 통하고 핸들러매핑을 통해서 어떠한 주소를 가진 컨트롤러에 맵핑을 해야되는지 결정을 합니다.
다음으로 핸들러 인터셉터를 통과하고 그 후 우리가 작성한 컨트롤러로 해당 리퀘스트가 들어오고 서비스로직 그리고 DB를 통해 데이터를 처리하면 다시 핸들러인ㄷ터셉터로 들어가고 왔던곳으로 다시 들어가게된다.

우리가 비지니스 로직을 처리하다가 에러가 나면 Exception Handler 라는곳이 해당 에러를 캐치하게 되고  에러에 대한 응답을 만들어서 우리가 다시 한번 예외에 대한 처리에 응답을 내려줄수 있습니다.
해당 로직을 처리함녀서 예외가 발생하게 되면은 이셉션 핸들러에서 에러구문을 처리한다.
우리가 직접 서비스 로직을 작성을 하면서 예상하지 못했던 예외가 발생할 수 있고 이셉션핸들러로 응답을 줄수잇고 또는 예측했던 예외를 일부러 터트릴수있다.

그렇기 때문에 해당 비지니스로직을 작성할때 예외에 대해서 크게 개의치 않고 작성이 가능하다.

try catch 로 하나하나 찾아서 묶어주는 방법은 광장히 비효율적이기도 하며 하나하나 찾아가는것도 힘들다 그래서 이러한 부분들을 우리는 글로벌하게 처리할 필요가 있다.
그것이 입섹션에러이빈다. 밖에 패키지를 만들어서 입셉셕만들

@RestControllerAdvice 를 사용하면 restApi가 사용하는 곳에 얘외가 일어나는것을 감지을 하게됩니다.
그러면 감지 후에는 어떻게 이 api를 인식할수 있는지 메소드를 만들보자

RestControllerAdvice 모든 컨트롤러에서 나오는 예외를 잡아준다.
하지만 우리가 프로그패밍을 하다보면은 조금 더 명시적으로 지정을 해줘야 될때가 있습니다.
그래서 그럴때는 어떠한 방식을 할수 잇는지 같이 한번 보도록하겠스빈다.

같은 컨트롤러 레벨에서 추가도 가능합니다.
코드가 길어지면 추천하지 않고 그냥 따로 컨트롤러를 만들어서 사용하는것을 추천한다.

@RestControllerAdvice(basePackages = "com.example.restapi.controller")
이런식으로 만들어서 특별한 베이스 패키지를 통해서도 지정이 가능하다.

특정 클래스도 지정이 가능하다.
@RestControllerAdvice(basePackages = "RestApiBController.class")
해당 이 클래스에서만 예외를 잡아주겟다는것이 가능하고 배열로도 가능하기 때문에 여러가지의 클래스들을 추가할수 있다.
또 다른 방법은 어노테이션을 지정해서 사용을 할수도 있다. 즉 커스텀한 어노테이션을 만들어서 해당 클래스가 어노테이션을 자기고 있다면 예외를 처리해주겠다라고 할수있다.


@Order에서 밸류값은 이미 integer = integer_max_value 이므로 굳이 글로벌api익셉션에서 선언을 할필요가 없고 글로벌에피아이익셉션 보다 먼저 실행을 시키려는 restapiExceptionhandler에
@Order을 선언해주고 값으로 1을 주면 최대 값보다 높으므로 먼저 실핻이 됩니다.
글로벌은 기본으로 세팅되어있는 최소값이기때문에 오더에1을 주면 글로벌보다 높기 때문에 먼저 실행이 됩니다.
public @interface Order {

	/**
	 * The order value.
	 * <p>Default is {@link Ordered#LOWEST_PRECEDENCE}.
	 * @see Ordered#getOrder()
	 */
	int value() default Ordered.LOWEST_PRECEDENCE;

}
	int LOWEST_PRECEDENCE = Integer.MAX_VALUE;
오더값은 마이너스일수록 가장 늦게 처리되고 양수일수록 (+) 해당값보다 먼저 처리가 된다.
글로벌 익셉션이 디폴트로 넣어주고 가야지 된다
반드시 어떠한 에러가 터지더라도 저희 서버는 동일한 응답을 내려야 되기 때문에 default 넣어주고 가시는게 가장 좋다.

클라이언트 측에서 서버에 요청을 했을 때 이러한 검증과정에서 에러가 나게 된다면 해당 에러에 대해서 너는 이름을 넣지 않았어 또는 이메일 양식이 맞지 않아 또는 핸드폰 번호가 ㅇ벗어 라는 등의 응답을 내려줘야 되는데
로직들이 만약에 서비스 로직을 검사하는 등의 정보를 해야됨
근데 요청을 받는 값이 많이지면 많아질수록 이 부분의 길이는 길어질 수 밖에 없다.
각 항목에 대해서 검사를 한다면 워낙에 양이 많기 때문에 이런 검증 과정이 길어지고 실질적으로 중요한 서비스 로직에 대해서는 많이 누락이 된다.

이러한것들을 해결하기 위해서 스프링부트에서는 스프링부트스타트업 벨리데이션이라는 디펜던시를 통해서 저희가 밸리데이션을 할수도 있다.
해당 밸리데ㅣ션의 스펙은 밸리데이션 org에 가면 스펙이 있다.
밸리데이션을 할때 핸드폰 번호 정규식
"^\\d{2,3{-\\d{3,4}-\\d{4}$"

밸리데이션을 사용하는 이유
1. 유효성 검증 하는 코드의 길이가 너무 길다.
2. service logic 에 대해서 방해가 된다.
3. 흩어져 있는 경우 어디서 검증  되었는지 찾기 힘들다. <-- 일관성을 찾기 어려워질수있다 이유는 여러명의 개발자가 개발을 하기 때문에
4. 검증 로직이 변경되는 경우 테스트 코드 등, 전체 로직이 흔들릴수 있다.


//valid 어노테이션을 달아주면 요청이 들어올때 자동으로 해당 클래스에 대해서 어노테이션을 기반으로 검증을 해주게된다.

요청을 보낼때도 검증을 하게되는데 이것을 요청 받는 곳에서도 @Valid를 선언을 해주어야된다. 널값이어도 되지만 검증이 필요하다.
해당 api 객체를 검증하려면 해당 부분에 @Valid를 해주면 같이 진행된다.

api<? extends Object> 를 하면 자바에서 모든 클래스는 Object를 상속받기때문에 모든 타입을 제네릭 오브젝트로 받을수 있다.

@Retention(RetentionPolicy.RUNTIME)
retention 은 언제 실행 시킬지에 대한 어노테이션이빈다. retentionpolicy.runtime을 쓰면 실행 시에만 한다.